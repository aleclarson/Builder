// Generated by CoffeeScript 1.12.4
var Builder, Mixin, NamedFunction, Property, PureObject, Super, ValueMapper, applyChain, assertType, bind, buildType, define, emptyFunction, forbiddenKinds, frozen, hidden, inArray, initTypeCount, instanceID, instanceType, isDev, isType, mutable, reactive, ref, ref1, setKind, setType, sync;

ref = require("Property"), frozen = ref.frozen, hidden = ref.hidden, reactive = ref.reactive;

ref1 = Property = require("Property"), mutable = ref1.mutable, frozen = ref1.frozen;

NamedFunction = require("NamedFunction");

emptyFunction = require("emptyFunction");

ValueMapper = require("ValueMapper");

PureObject = require("PureObject");

assertType = require("assertType");

applyChain = require("applyChain");

inArray = require("in-array");

setType = require("setType");

setKind = require("setKind");

isType = require("isType");

define = require("define");

Super = require("Super");

Mixin = require("Mixin");

isDev = require("isDev");

bind = require("bind");

sync = require("sync");

instanceType = null;

instanceID = null;

Builder = NamedFunction("Builder", function(name) {
  var phases, self;
  if (name != null) {
    assertType(name, String);
  }
  phases = {
    init: [],
    willBuild: [],
    didBuild: []
  };
  self = Object.create(Builder.prototype, {
    _name: {
      value: name
    },
    _kind: {
      value: false,
      writable: true
    },
    _phases: {
      value: phases
    }
  });
  isDev && self.didBuild(initTypeCount);
  return self;
});

module.exports = Builder;

Builder.Mixin = Mixin.create({
  methods: ["initInstance", "defineValues", "defineFrozenValues", "defineReactiveValues", "defineProperties", "definePrototype", "defineMethods", "overrideMethods", "defineHooks", "defineBoundMethods", "defineGetters", "defineStatics", "addMixin", "addMixins", "willBuild", "didBuild"]
});

Object.assign(Builder.prototype, {
  abstract: function() {},
  inherits: function(kind) {
    if (this._kind !== false) {
      throw Error("'kind' is already defined!");
    }
    if (inArray(forbiddenKinds, kind)) {
      throw Error("Cannot inherit from '" + kind.name + "'!");
    }
    if (!((kind instanceof Function) || (kind === null))) {
      throw Error("'kind' must be a kind of Function (or null)!");
    }
    this._kind = kind;
    this.__didInherit(kind);
  },
  createInstance: function(createInstance) {
    assertType(createInstance, Function);
    if (this._createInstance) {
      throw Error("'createInstance' has already been called!");
    }
    mutable.define(this, "_createInstance", {
      value: createInstance
    });
  },
  trace: function() {
    isDev && this._phases.init.push(function() {
      return mutable.define(this, "__stack", {
        value: Error()
      });
    });
  },
  initInstance: function(func) {
    var initInstance;
    assertType(func, Function);
    initInstance = function(args) {
      return func.apply(this, args);
    };
    isDev && (initInstance = bind.toString(func, initInstance));
    this._phases.init.push(initInstance);
  },
  defineFunction: function(func) {
    assertType(func, Function);
    this._kind = Function;
    this._createInstance = function() {
      var self;
      self = function() {
        return func.apply(self, arguments);
      };
      isDev && (self.toString = function() {
        return func.toString();
      });
      return self;
    };
  },
  defineValues: (function() {
    var defineValue;
    defineValue = function(obj, key, value) {
      var prop;
      if (value !== void 0) {
        prop = {
          value: value,
          writable: true
        };
        prop.enumerable = !key.startsWith("_");
        Object.defineProperty(obj, key, prop);
      }
    };
    return function(values) {
      var mapValues;
      mapValues = ValueMapper(values, defineValue);
      this._phases.init.push(function(args) {
        return mapValues(this, args);
      });
    };
  })(),
  defineFrozenValues: (function() {
    var defineValue;
    defineValue = function(obj, key, value) {
      if (value !== void 0) {
        frozen.define(obj, key, {
          value: value
        });
      }
    };
    return function(values) {
      var mapValues;
      mapValues = ValueMapper(values, defineValue);
      this._phases.init.push(function(args) {
        return mapValues(this, args);
      });
    };
  })(),
  defineReactiveValues: (function() {
    var defineValue;
    defineValue = function(obj, key, value) {
      if (value !== void 0) {
        reactive.define(obj, key, {
          value: value
        });
      }
    };
    return function(values) {
      var mapValues;
      mapValues = ValueMapper(values, defineValue);
      this._phases.init.push(function(args) {
        return mapValues(this, args);
      });
    };
  })(),
  defineProperties: function(props) {
    assertType(props, Object);
    props = sync.map(props, function(prop, key) {
      assertType(prop, Object, key);
      return Property(prop);
    });
    this._phases.init.push(function() {
      var key, prop;
      for (key in props) {
        prop = props[key];
        prop.define(this, key);
      }
    });
  },
  definePrototype: function(props) {
    assertType(props, Object);
    this.didBuild(function(type) {
      var key, prop;
      for (key in props) {
        prop = props[key];
        if (!isType(prop, Object)) {
          prop = {
            value: prop
          };
        }
        if (!(prop.set || prop.writable)) {
          prop.frozen = true;
        }
        define(type.prototype, key, prop);
      }
    });
  },
  defineMethods: function(methods) {
    assertType(methods, Object);
    isDev && this._assertUniqueMethodNames(methods);
    this.didBuild(function(type) {
      var key, method;
      for (key in methods) {
        method = methods[key];
        mutable.define(type.prototype, key, {
          value: method
        });
      }
    });
  },
  overrideMethods: function(methods) {
    var hasInherited;
    assertType(methods, Object);
    if (this._kind === false) {
      throw Error("Must call 'inherits' before 'overrideMethods'!");
    }
    hasInherited = this._inheritMethods(methods);
    this.didBuild(function(type) {
      var key, method;
      hasInherited && Super.augment(type);
      for (key in methods) {
        method = methods[key];
        frozen.define(type.prototype, key, {
          value: method
        });
      }
    });
  },
  defineHooks: (function() {
    var getDefaultHook;
    getDefaultHook = function(keyPath) {
      if (isDev) {
        return function() {
          throw Error("Must override '" + keyPath + "'!");
        };
      } else {
        return emptyFunction;
      }
    };
    return function(hooks) {
      var name;
      assertType(hooks, Object);
      name = this._name ? this._name + "::" : "";
      return this.didBuild(function(type) {
        var hook, key;
        for (key in hooks) {
          hook = hooks[key];
          if (hook == null) {
            hook = getDefaultHook(name + key);
          }
          type.prototype[key] = hook;
        }
      });
    };
  })(),
  defineBoundMethods: function(methods) {
    assertType(methods, Object);
    this.didBuild(function(type) {
      var prototype;
      prototype = type.prototype;
      sync.each(methods, function(method, key) {
        return frozen.define(prototype, key, {
          get: function() {
            var value;
            value = bind.func(method, this);
            frozen.define(this, key, {
              value: value
            });
            return value;
          }
        });
      });
    });
  },
  defineGetters: function(getters) {
    assertType(getters, Object);
    this.didBuild(function(type) {
      var get, key, prototype;
      prototype = type.prototype;
      for (key in getters) {
        get = getters[key];
        assertType(get, Function, key);
        frozen.define(prototype, key, {
          get: get
        });
      }
    });
  },
  defineStatics: function(statics) {
    var props;
    assertType(statics, Object);
    props = sync.map(statics, function(options, key) {
      if (!isType(options, Object)) {
        options = {
          value: options
        };
      }
      return Property(options);
    });
    this.didBuild(function(type) {
      var key, prop;
      for (key in props) {
        prop = props[key];
        prop.define(type, key);
      }
    });
  },
  addMixin: function(mixin, options) {
    assertType(mixin, Function, "mixin");
    mixin(this, options);
  },
  addMixins: function(mixins) {
    var i, index, len, mixin;
    assertType(mixins, Array, "mixins");
    for (index = i = 0, len = mixins.length; i < len; index = ++i) {
      mixin = mixins[index];
      assertType(mixin, Function, "mixins[" + index + "]");
      mixin(this, {});
    }
  },
  willBuild: function(func) {
    assertType(func, Function);
    this._phases.willBuild.push(func);
  },
  didBuild: function(func) {
    assertType(func, Function);
    this._phases.didBuild.push(func);
  },
  construct: function() {
    return this.build().apply(null, arguments);
  },
  build: function() {
    var type;
    if (this._built) {
      throw Error("Cannot build more than once!");
    } else {
      frozen.define(this, "_built", {
        value: true
      });
    }
    if (this._kind === false) {
      this._kind = this._defaultKind;
    }
    applyChain(this._phases.willBuild, this);
    this.__willBuild();
    type = this._createType();
    setKind(type, this._kind);
    applyChain(this._phases.didBuild, null, [type]);
    this.__didBuild(type);
    return type;
  }
});

define(Builder.prototype, {
  _defaultKind: Object,
  _createType: function() {
    var buildArgs, buildInstance, name;
    name = this._name || "";
    buildArgs = this.__createArgBuilder();
    assertType(buildArgs, Function);
    buildInstance = this.__createInstanceBuilder();
    assertType(buildInstance, Function);
    return buildType(name, buildArgs, buildInstance);
  },
  _getBaseCreator: function() {
    var createInstance, kind;
    kind = this._kind;
    if (!(createInstance = this._createInstance)) {
      createInstance = kind === null ? PureObject.create : kind;
    }
    if (kind === this._defaultKind) {
      return this._defaultBaseCreator;
    }
    return function(args) {
      var instance;
      instance = createInstance.apply(this, args);
      instanceType && setType(instance, instanceType);
      return instance;
    };
  },
  _defaultBaseCreator: function() {
    if (this.constructor !== instanceType) {
      return Object.create(instanceType.prototype);
    } else {
      return this;
    }
  },
  _assertUniqueMethodNames: isDev ? function(methods) {
    var inherited, key, kind, method, prefix;
    kind = this._kind;
    prefix = this._name ? this._name + "::" : "";
    for (key in methods) {
      method = methods[key];
      if (method === void 0) {
        continue;
      }
      if (!(method instanceof Function)) {
        throw TypeError("'" + (prefix + key) + "' must be a kind of Function!");
      }
      if (!kind) {
        continue;
      }
      if (!(inherited = Super.findInherited(kind, key))) {
        continue;
      }
      throw Error(("Inherited methods cannot be redefined: '" + (prefix + key) + "'\n\n") + "Call 'overrideMethods' to explicitly override!");
    }
  } : void 0,
  _inheritMethods: function(methods) {
    var hasInherited, inherited, key, kind, method, prefix;
    if (!(kind = this._kind)) {
      throw Error("Must have parent type before calling '_inheritMethods'!");
    }
    prefix = this._name ? this._name + "::" : "";
    hasInherited = false;
    for (key in methods) {
      method = methods[key];
      assertType(method, Function, prefix + key);
      inherited = Super.findInherited(kind, key);
      if (!inherited) {
        throw Error("Cannot find method to override for: '" + (prefix + key) + "'!");
      }
      if (0 > method.toString().indexOf("this.__super")) {
        continue;
      }
      hasInherited = true;
      methods[key] = Super(inherited, method);
    }
    return hasInherited;
  }
});

define(Builder.prototype, {
  __createArgBuilder: function() {
    return emptyFunction.thatReturnsArgument;
  },
  __createInstanceBuilder: function() {
    var buildInstance, createInstance, instPhases;
    createInstance = this._getBaseCreator();
    instPhases = this._phases.init;
    return buildInstance = function(type, args, context) {
      var instance;
      if (!instanceType) {
        instanceType = type;
        isDev && (instanceID = type.__count++);
      }
      instance = createInstance.call(context, args);
      if (instanceType) {
        isDev && mutable.define(instance, "__name", {
          value: instanceType.getName() + "_" + instanceID
        });
        instanceType = null;
        isDev && (instanceID = null);
      }
      applyChain(instPhases, instance, [args]);
      return instance;
    };
  },
  __didInherit: emptyFunction,
  __willBuild: emptyFunction,
  __didBuild: emptyFunction
});

if (isDev) {
  initTypeCount = function(type) {
    return mutable.define(type, "__count", {
      value: 0
    });
  };
  forbiddenKinds = [String, Boolean, Number, Array, Symbol, Date, RegExp];
}

buildType = isDev ? function(name, buildArgs, buildInstance) {
  return Function("global", "buildArgs", "buildInstance", "var type;" + ("return type = function " + name + "() {\n") + "  var context = this === global ? null : this;\n" + "  var args = buildArgs(arguments, context);\n" + "  return buildInstance(type, args, context);\n" + "}")(global, buildArgs, buildInstance);
} : function(name, buildArgs, buildInstance) {
  var type;
  type = function() {
    var args, context;
    context = this === global ? null : this;
    args = buildArgs(arguments, context);
    return buildInstance(type, args, context);
  };
  type.getName = function() {
    return name;
  };
  return type;
};
