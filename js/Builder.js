// Generated by CoffeeScript 1.12.4
var Builder, NamedFunction, PhaseMap, Property, PropertyMap, Super, assertType, bind, createType, defineBoundMethod, defineFrozenValue, defineReactiveValue, defineValue, emptyFunction, frozen, getMethodPath, initTypeCount, instanceID, instanceType, isDev, isType, mixinPrototype, mutable, prototype, reactive, ref, setKind, setProto, setType, sync;

ref = Property = require("Property"), mutable = ref.mutable, frozen = ref.frozen, reactive = ref.reactive;

NamedFunction = require("NamedFunction");

emptyFunction = require("emptyFunction");

assertType = require("assertType");

setProto = require("setProto");

setType = require("setType");

setKind = require("setKind");

isType = require("isType");

Super = require("Super");

isDev = require("isDev");

bind = require("bind");

sync = require("sync");

PropertyMap = require("./PropertyMap");

createType = require("./createType");

PhaseMap = require("./PhaseMap");

instanceType = null;

instanceID = null;

Builder = NamedFunction("Builder", function(name) {
  var key, self, value, values;
  if (name != null) {
    assertType(name, String);
  }
  values = {
    _name: name,
    _used: Object.create(null),
    _phases: PhaseMap(),
    _values: PropertyMap(),
    _protos: PropertyMap(),
    _statics: PropertyMap()
  };
  for (key in values) {
    value = values[key];
    values[key] = {
      value: value
    };
  }
  values._kind = {
    value: false,
    writable: true
  };
  self = Object.create(Builder.prototype, values);
  isDev && self._phases.push("didBuild", initTypeCount);
  return self;
});

module.exports = Builder;

prototype = {
  abstract: function() {},
  inherits: function(kind) {
    if (this._kind !== false) {
      throw Error("'kind' is already defined!");
    }
    if (!((kind instanceof Function) || (kind === null))) {
      throw Error("'kind' must be a kind of Function (or null)!");
    }
    if (kind && kind._used) {
      setProto(this._used, kind._used);
    }
    this._kind = kind;
    this.__didInherit(kind);
  },
  createInstance: function(createInstance) {
    assertType(createInstance, Function);
    if (this._createInstance) {
      throw Error("'createInstance' has already been called!");
    }
    Object.defineProperty(this, "_createInstance", {
      value: createInstance
    });
  },
  trace: function() {
    isDev && this._values.push(function() {
      return Object.defineProperty(this, "__stack", {
        value: Error()
      });
    });
  },
  defineFunction: function(func) {
    assertType(func, Function);
    this._kind = Function;
    this._createInstance = function() {
      var self;
      self = function() {
        return func.apply(self, arguments);
      };
      isDev && (self.toString = function() {
        return func.toString();
      });
      return self;
    };
  },
  construct: function() {
    return this.build().apply(null, arguments);
  },
  build: function() {
    var type;
    if (this._built) {
      throw Error("Cannot build more than once!");
    } else {
      frozen.define(this, "_built", {
        value: true
      });
    }
    if (this._kind === false) {
      this._kind = this._defaultKind;
    }
    this._phases.apply("willBuild", this);
    this.__willBuild();
    type = this._createType();
    setKind(type, this._kind);
    this._protos.apply(type.prototype);
    this._statics.apply(type);
    Object.defineProperties(type, {
      displayName: {
        value: this._name || ""
      },
      _used: {
        value: this._used
      }
    });
    this._phases.apply("didBuild", null, [type]);
    this.__didBuild(type);
    return type;
  }
};


/* Methods available to mixins */

Object.assign(prototype, mixinPrototype = {
  initInstance: function(callback) {
    assertType(callback, Function);
    this._values.push(callback);
  },
  createValue: function(key, create) {
    return this._createValue(key, create, defineValue);
  },
  defineValue: function(key, value) {
    return this._defineValue(key, value, defineValue);
  },
  createFrozenValue: function(key, create) {
    return this._createValue(key, create, defineFrozenValue);
  },
  defineFrozenValue: function(key, value) {
    return this._defineValue(key, value, defineFrozenValue);
  },
  createReactiveValue: function(key, create) {
    return this._createValue(key, create, defineReactiveValue);
  },
  defineReactiveValue: function(key, value) {
    return this._defineValue(key, value, defineReactiveValue);
  },
  defineValues: function(values) {
    this._values.push(defineValue, values);
  },
  defineFrozenValues: function(values) {
    this._values.push(defineFrozenValue, values);
  },
  defineReactiveValues: function(values) {
    this._values.push(defineReactiveValue, values);
  },
  defineProperty: function(key, prop) {
    prop = Property(prop);
    this._values.push(function() {
      prop.define(this, key);
    });
  },
  defineProperties: function(props) {
    return this._defineProperties(this._values, props);
  },
  definePrototype: function(props) {
    return this._defineProperties(this._protos, props);
  },
  defineMethod: function(name, method) {
    assertType(name, String);
    isDev && this._validateMethod(name, method);
    this._protos.push(function() {
      return defineValue(this, name, method);
    });
  },
  defineMethods: function(methods) {
    isDev && this._validateMethods(methods);
    this._protos.push(defineValue, methods);
  },
  overrideMethods: function(methods) {
    var inherited, key, method, shouldAugment;
    assertType(methods, Object);
    if (this._kind === false) {
      throw Error("Must call 'inherits' before 'overrideMethods'!");
    }
    shouldAugment = false;
    for (key in methods) {
      method = methods[key];
      if (method === void 0) {
        continue;
      }
      if (!(method instanceof Function)) {
        throw TypeError("'" + (getMethodPath(this._name, key)) + "' must be a kind of Function!");
      }
      if (!(inherited = Super.findInherited(this._kind, key))) {
        throw Error("Cannot find method to override for: '" + (getMethodPath(this._name, key)) + "'!");
      }
      if (0 <= method.toString().indexOf("this.__super")) {
        methods[key] = Super(inherited, method);
        shouldAugment = true;
      }
    }
    this._protos.push(defineValue, methods);
    shouldAugment && this._phases.push("didBuild", Super.augment);
  },
  defineHooks: function(methods) {
    var name;
    assertType(methods, Object);
    isDev && this._validateMethods(methods);
    name = this._name;
    this._protos.push(function() {
      var key, method;
      for (key in methods) {
        method = methods[key];
        if (method === null) {
          if (isDev) {
            method = function() {
              throw Error("Must override '" + (getMethodPath(name, key)) + "'!");
            };
          } else {
            method = emptyFunction;
          }
        }
        if (!method) {
          continue;
        }
        defineValue(this, key, method);
      }
    });
  },
  defineBoundMethods: function(methods) {
    assertType(methods, Object);
    this._protos.push(function() {
      var key, method;
      for (key in methods) {
        method = methods[key];
        defineBoundMethod(this, key, method);
      }
    });
  },
  defineGetters: function(getters) {
    assertType(getters, Object);
    this._protos.push(function() {
      var get, key;
      for (key in getters) {
        get = getters[key];
        assertType(get, Function, key);
        frozen.define(this, key, {
          get: get
        });
      }
    });
  },
  defineStatics: function(statics) {
    return this._defineProperties(this._statics, statics);
  },
  addMixin: function(mixin, options) {
    assertType(mixin, Function, "mixin");
    mixin(this, options);
  },
  addMixins: function(mixins) {
    var i, index, len, mixin;
    assertType(mixins, Array, "mixins");
    for (index = i = 0, len = mixins.length; i < len; index = ++i) {
      mixin = mixins[index];
      assertType(mixin, Function, "mixins[" + index + "]");
      mixin(this, {});
    }
  },
  willBuild: function(callback) {
    this._phases.push("willBuild", callback);
  },
  didBuild: function(callback) {
    this._phases.push("didBuild", callback);
  }
});


/* Subclass hooks */

Object.assign(prototype, {
  __didInherit: emptyFunction,
  __willBuild: emptyFunction,
  __didBuild: emptyFunction,
  __createArgBuilder: function() {
    return emptyFunction.thatReturnsArgument;
  },
  __createInstanceBuilder: function() {
    var buildInstance, createInstance, values;
    values = this._values;
    createInstance = this._getInstanceCreator();
    return buildInstance = function(type, args, context) {
      var instance;
      if (!instanceType) {
        instanceType = type;
        isDev && (instanceID = type.__count++);
      }
      instance = createInstance.call(context, args);
      if (instanceType) {
        if (isDev) {
          Object.defineProperty(instance, "__name", {
            value: instanceType.getName() + "_" + instanceID
          });
          instanceID = null;
        }
        instanceType = null;
      }
      values.apply(instance, args);
      return instance;
    };
  }
});


/* Internal prototype */

Object.assign(prototype, {
  _defaultKind: Object,
  _needs: function(name) {
    if (this._used[name]) {
      return false;
    }
    this._used[name] = true;
    return true;
  },
  _createValue: function(key, create, define) {
    this._values.push(function() {
      var value;
      value = create.apply(this, arguments);
      return define(this, key, value);
    });
  },
  _defineValue: function(key, value, define) {
    this._values.push(function() {
      return define(this, key, value);
    });
  },
  _defineProperties: function(values, props) {
    assertType(values, PropertyMap);
    assertType(props, Object);
    props = sync.map(props, function(prop, key) {
      if (!isType(prop, Object)) {
        prop = {
          value: prop
        };
      }
      assertType(prop, Object, key);
      return Property(prop);
    });
    values.push(function() {
      var key, prop;
      for (key in props) {
        prop = props[key];
        prop.define(this, key);
      }
    });
  },
  _createType: function() {
    var buildArgs, buildInstance, name;
    name = this._name || "";
    buildArgs = this.__createArgBuilder();
    assertType(buildArgs, Function);
    buildInstance = this.__createInstanceBuilder();
    assertType(buildInstance, Function);
    return createType(name, buildArgs, buildInstance);
  },
  _rootCreator: function() {
    return Object.create(instanceType.prototype);
  },
  _getInstanceCreator: function() {
    var createInstance, kind;
    if (!(createInstance = this._createInstance)) {
      kind = this._kind;
      if (kind === null || kind === Object) {
        return this._rootCreator;
      }
      createInstance = kind === this._defaultKind ? this._defaultCreator || kind : kind;
    }
    return function(args) {
      var instance;
      instance = createInstance.apply(this, args);
      instanceType && setType(instance, instanceType);
      return instance;
    };
  },
  _validateMethod: isDev ? function(key, method) {
    if (!method) {
      return;
    }
    if (!(method instanceof Function)) {
      throw TypeError("'" + (getMethodPath(this._name, key)) + "' must be a kind of Function!");
    }
    if (!this._kind) {
      return;
    }
    if (!Super.findInherited(this._kind, key)) {
      return;
    }
    throw Error(("Cannot redefine an inherited method: '" + (getMethodPath(this._name, key)) + "'\n\n") + "Call 'overrideMethods' to explicitly override!");
  } : void 0,
  _validateMethods: isDev ? function(methods) {
    var key, method;
    assertType(methods, Object);
    for (key in methods) {
      method = methods[key];
      this._validateMethod(key, method);
    }
  } : void 0
});

(function() {
  var key, value;
  for (key in prototype) {
    value = prototype[key];
    if (value === void 0) {
      continue;
    }
    Object.defineProperty(Builder.prototype, key, {
      value: value
    });
  }
})();

Builder.Mixin = require("Mixin").create({
  methods: Object.keys(mixinPrototype)
});

isDev && (initTypeCount = function(type) {
  return mutable.define(type, "__count", {
    value: 0
  });
});

isDev && (getMethodPath = function(typeName, methodName) {
  if (typeName) {
    return typeName + "::" + methodName;
  } else {
    return methodName;
  }
});

defineValue = function(obj, key, value) {
  var prop;
  prop = {
    value: value,
    writable: true
  };
  prop.enumerable = !key.startsWith("_");
  return Object.defineProperty(obj, key, prop);
};

defineFrozenValue = function(obj, key, value) {
  return frozen.define(obj, key, {
    value: value
  });
};

defineReactiveValue = function(obj, key, value) {
  return reactive.define(obj, key, {
    value: value
  });
};

defineBoundMethod = function(obj, key, method) {
  return mutable.define(obj, key, {
    get: function() {
      var value;
      value = bind.func(method, this);
      mutable.define(this, key, {
        value: value
      });
      return value;
    }
  });
};
